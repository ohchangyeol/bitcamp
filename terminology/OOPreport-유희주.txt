
<<< OOP의 이해 / Report 제출 >>>

1. OOP(Object Oriented Programming)
강의를 듣기 전 OOP란 절차지향 프로그래밍보다 유연하지만 실행속도가 느리다는 특징만을 알고 있었을 뿐 개념을 확실히 잡지 못했다. 
OOP란 현실세계에서 일어나는 일들을 분석 설계 구현하여 시스템화하는 방법론 중 가장 많이 사용되는 방법론이다.
현실세계의 모든 대상에게서 공통적인 것을 추출하여 클래스로 만들고 사용하는 모든 일련의 과정을 OOP 개념이라고 하는데
이 OOP 개념을 지원하는 c, c++, c#, java 등을 OOPL(Object Oriented Programming Lenguage)라고 한다.

2. Object(객체) 
많은 예시를 보았을 때 Object와 Class는 붕어빵과 붕어빵기계라고 표현한다. 
하지만 붕어빵 기계(Class)로 만든 붕어빵(Object)이라는 것이 잘 이해가 가지 않았다.

Object란 컴퓨터로 표현하기 위해 필요한 현실세계에 존재하는 모든 대상을 뜻한다.
Object는 실체가 있는 물리적인 객체(의자, 책상, 책 등)와 실체가 없는 개념적인 객체(결제, 계좌이체 등)가 있다.
또 Object는 class의 instance라고 불린ㄷ.

*instance란 컴퓨터의 저장공간에서 할당된 실체인데 즉, 사용하기 위해 new 라는 keyword를 이용해 메모리를 할당한 것이다.

3. Class 
Object를 정의하는 틀 또는 설계도이다. 붕어빵틀에 비유하는 이유는 붕어빵을 만들때 사용되는 틀이기 때문이다.
이처럼 class라는 틀 또는 설계도로 여러 객체를 생성하는 것이다.
클래스는 객체의 상태를 나타내는 field와 객체의 행동을 나타내는 method로 구성된다.
field는 변수를 의미하고, method는 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라고 할 수 있다.
(int a; 에서 a를 변수라 하며, public void A() 같은 구문을 메소드라고 한다.)

위의 내용을 정리하면서도 정확한 개념이 무엇인지 확실히 알지 못했는데 강의를 들은 후 Class에 대한 개념이 살짝 잡힌 것 같다. 

Class란 현실세계에 존재하는 모든 대상(Object) 중 공통점을 뽑아 구현하는 것으로 Application과 Beans, 두가지 종류로 나눌 수 있다.
Application은 main Method가 존재하는 Class로 실행이 가능하고 Beans는 main Method가 없어 실행하지 못하며 현실세계를 표현한 것이다.
또 다른 말로 Object Modeling이라고 한다.

4. abstraction(추상화) 
자세히 구현된 것을 간결하게 만드는 것을 추상화라고 한다. 존재가 가지고 있는 가장 핵심적인 공통점을 파악해가는 것이다.
(사람은 -> 포유류 -> 동물 -> 사물)

=> 현실세계의 모든 대상(Object)의 공통적인 attribute와 hehavior을 추출하여 class로 만드는 과정을 뜻한다.


5. Generalization(일반화) / Inheritance(상속)
자식은 부모한테 집, 돈, 땅 등을 상속받고 집을 팔거나 돈을 쓰거나 하는 행위를 할 수 있다.
이처럼 상속받은 super class(부모)의 속성들을 sub class(자식)가 사용할 수 있는 것을 Inheritance라고 한다.
super class와 sub class 말고도 parent, base (상속하는) child, derived (상속받는)이라고 칭할 수 있다.
기존 작성된 클래스를 상속받는 것이기 때문에 재활용(변수나 메소드)이 가능하고 중복 작성을 하지 않아도 된다.

상속 = 공유의 개념, 일반화, 구체화 등을 모두 합쳐 칭한다. (extends로 사용(확장))
Hierarchy(계층화)를 통해 확장성과 재사용성, 일관성을 유지할 수 있다.

Generalization은 상속의 방법 중 하나로 공통의 특징을 뽑아내는 것이다.
여러개의 class(사람)에서 공통된 특징(눈, 코, 입)들을 추출하여 하나의 일반화된 상위 class(사람의 공통된 특징)에 병합하는 과정이라고 한다.
sub class에 있는 변수와 메소드는 super class에 있는 변수와 메소드를 사용할 수 있으나
super class의 변수와 메소드는 sub class에 있는 변수와 메소드를 사용할 수 없다.

Generalization은 포유류, 조류, 전자기기, 통신기기 등의 공통적인 특징을 추출하여 사물이라고 묶을 수 있기 때문에
추상화 수준이 높다고 할 수 있다.

6.  Specialization(구체화)
전체를 보고 각각의 특징을 만들어 내는 것으로 이미 존재하는 class에서 새로운 하위 class를 생성하는 것이다.
Generalization은 공통된 특징을 뽑아서 추상화 수준을 높이는 거라면 Specialization은 Object에서 특징을 분해하여 더욱 구체적으로 만드는 것이라는 차이점이 있다.

예시) 사물 -> 동물/기계 -> 포유류/조류/전자기기 -> ...... 
위의 예시처럼 전체에서 특징을 나누어 세세하게 나누는 것을 Specialization이라고 한다.

7. Realization
추상화된 것의 구현이라는데 잘 모르겠다.

8. Association
다른 두 객체들의 다양성을 표현하며, 1:N 1:1 N:1 N:N 을 형성할 수 있다.
정확히 어떤 개념인지 이해가 가지 않는다.

9. dependency (의존)
하나의 클래스를 다른 클래스들이 이용하는 것을 dependency라고 부른다.

	public class A {
		void 호출() {
			SOP("main에서 부릅니다.");
		}
	}
	
	public class main {
		....void main(....) {
			A a = new A();
			a.호출();
		}
	}
위의 코드를 보면 클래스 A의 메소드인 호출을 사용하기 위해 A를 생성(new A())하고 메소드를 호출(a.호출())한다.
A 클래스의 메소드를 바로 가져올 수 있어 간편하지만 내용이 바뀐다면 그 클래스를 의존하는 모든 클래스의 결과도 바뀐다.

강의를 들은 후 dependency에 다시 알게 되었다.
독수리, 고래, 코끼리, TV, 카메라, 전화기 가 있을 때 동물가 기기로 나눠라라고 문제가 주어진다면 
(독수리, 고래, 코끼리), (TV, 카메라, 전화기) 두 개의 class로 나눌 것이다. 
하지만 아무런 조건도 주어지지 않았다면 전체를 묶어 사물로 표현하던가 더욱 세세히 나눠 포유류, 조류,...등등으로 나눌 것이다.
이처럼 어떤 시스템을 만들 때 필요한 Object가 달라지는 것을 문제 영역에 dependency라고 한다.

10, Polymorphism(다형성)
polymorphism이란 여러개의 형태라고 직역할 수 있다.
다양한 방법으로 클래스나 메소드가 동작하는 것을 Polymorphism이라고 하는데 대표적으로 OverLoading과 Overrriding이 존재한다.

예를 들어, 아래와 같은 코드가 있을 때, 
	public class 동물 {
		void 출력() {
			System.out.println("동물입니다.");
		}
	}

	public class 사람 extends 동물 {}

	public class Main {
		public static....(...args) {
			동물 동 = new 동물();
			동물 동 = new 사람();
			사람 사 = new 사람();
		}
	}

위의 실행결과는 모두 동일하다.
super class인 동물에게 상속받았기 때문에 "동물입니다."라는 같은 출력결과가 나온다.
하지만 사람 사 = new 동물();은 참조가 불가능 하다. 
sub가 super class의 값을 상속받은 것이라 super에게는 자식을 참조할 수 있는 권한이 없다. (묵시적 형변환 참조)

매개변수가 다르지만 (void 메소드명(매개변수)) 같은 메소드명을 가지고 있는 것을 오버로딩 (OverLoading),
	void A(String) {}
	void A(int) {}

super class에게 상속받은 메소드를 다시 재정의하는 것을 오버라이딩(Overriding) 이라고 한다.
	class super {
		void A() {System.out.println("A");}
	}

	class sub extends super {
		void A() {System.out.println("A가 아니다.");}
	}

운전면허가 있으면 어떤 차종이든 운전할 수 있다.

11. Encapuslation / 절차은닉 / 정보은닉
Encapuslation는 관련이 있는 변수와 함수를 하나의 클래스로 묶고 외부에서 쉽게 접근하지 못하도록 한다.
감기약으로 비유하자면 캡슐로 된 감기약 속에는 여러가지의 가루, 또는 액체, 또는 다양한 것이 들어있지만 
이 모든 것들이 감기에 효과가 있는 성분(관련있는 변수와 함수)일 것이다.
감기약을 분해하기 전까지 다른 누군가가 성분을 변경할 수 없는 것이다.
때문에, 어떠한 클래스를 사용할 때 내부 동작이 어떻게 돌아가는지 어떤 객체들이 있는지 파악할 수 없다.
중요한 데이터들이 외부로 노출되는 것을 방어하기 때문에 보안이 가능하다. 이를 정보은닉이라고 한다.
하지만 어떠한 성분과 효과가 있는지 잘 몰라도 감기약의 복용 방법만 안다면 사람들은 언제든 그 감기약을 복용할 수 있다.
이러한 것을 절차은닉이라고 한다.사용자에게 사용 방법만 볼 수 있도록 하는 것이다.
캡슐화를 하게 되면 캡슐 안에 성분이 바뀌어도 사용방법은 달라지지 않고, 외부 다른 곳에 영향을 주지 않는다는 장점이 있다.


==============================================
System
- 오프라인에서 하던 업무들을 온라인으로 편하게 해결할 수 있는 것

Modeling
- System을 구현하기 전 기획하는 것

Model
- 기획의 결과물

UML(Unified Modeling Language)
- 개발자 간 의사소통을 원활하게 이루어지기 위한 표준화 모델링 언어 (ex.다이어그램)

coder / typist
- 모델링 설계부터 구현까지 수행하는 사람 / 코드를 따라 쓰는 사람(구현만 가능)

DB (DataBase)
- 수많은 자료(Data) 중 쓰레기를 사용할 수 있게 가공하는 것

WWW (World Wide Web)

O/S (Operating System)
- Application을 사용하기 위한 기반

Platform
- 환경을 제공해주는 것 (ex. 서비스를 사용하기 편하게 환경을 제공해주면 서비스 플랫폼) = > 상대적 개념

Application
- O/S 위에 필요한 program을 설치하는 것, O/S에 종속적 (운영체제 환경에 따라 설치 유무가 달라짐)

SDK (JDK)
- O/S로 부터 독립적(=Platform이 독립적) 으로 사용할 수 있게 하기 위해 설치하는 것 (개발 + (실행 => JRE가 포함되어 있음))

JRE (Java Runtime Environment)
- Java Application을 실행시킬 수 있게 해주는 Tool, 오라클에는 종속적, edit에는 독립적

Compile
- *.java를 *.class로 바꿔주는 것 (=> 인간이 작성한 코드를 컴퓨터가 이해할 수 있는 코드로 변경)

*.exe (Execute)

javac / java
- java를 compile / compile하여 생성된 class 파일을 실행

cmd (comend, 콘솔창)
- computer에게 명령을 내릴 수 있는 공간
- cd (change directory) - 디렉토리 변경
- md (make directory) - 디렉토리 생성
- dir (directory) - (현재)폴터 내역
- echo %변수% - 변수 값을 출력

CSV(Comma Separated Value)
- Space, Comma, -, \ 등등... 긴 내용을 구분해주기 위해 사용 (=> 진화한 것이 JSON)

path
- 어느 dir에서라도 java, javac를 실행시킬 수 있게 하기 위해 사용

notation
- 표기값

JVM (Java Virtual Machine)
- 자바를 실행하기 위한 가상 기계
- 다른 프로그램을 실행시키는 것이 목적인 프로그램 / 시스템 메모리 관리, java App을 위해 실행 관경 제공
- 최초로 실행 시키는 곳이 main Method

API (Application Programing Interface)
- 프로그램이 서로 상호작용하는 것을 도와줌
- 추상화, 캡슐화 된 Class들의 모임(?)

OOPL (Object Oriented Programming Language)
- OOP 개념을 지원하는 언어
- java, c, c#......

환경 변수
- 컴퓨터를 변하게 하는 수
- JAVA_HOME => Variable / %JAVA_HOME% => Literal

public      static       void      main     (String[]          args)
- 접근제어자     제어자      반환(데이터)타입     메소드명        데이터타입    인자(Argument)

int i; => Variable declaration (변수 선언)
i = 10; => Variable Assignment (값의 대입)

Keyword
- 이미 정해져 있는 이름, Identifier로 사용 불가능 (예약어)

Identifier
- 프로그래머가 정하는 이름 (식별자)

증감연산자
- post modification (value++)
- premodification (++value)

Data Type(Primitive / Reference)
- Primitive => boolean < char < byte < short < int < long < float < double
- Reference => String,,,,,

Call by Value / Call by Reference
- 값에 의한 호출 / 참조에 의한 호출

Casting (형변환)
- 묵시적 형변환 => 큰 데이터 타입에 작은 데이터 타입을 대입할 때 (자동으로 변환)
	byte k = 3;
	int i = k;

- 명시적 형변환 => 작은 데이터 타입에 큰 데이터 타입을 대입할 때 (데이터 범위를 넘으면 쓰레기값이 됨)
	byte i = (int) k;

Array (배열)
- 같은 데이터 타입의 여러 변수를 하나의 묶음으로 다루는 것
- 1. String[] array;
     array = new String[길이]; 
  2. String array[] = new String[길이]
   ====> 이런식으로 사용할 경우 길이 지정 필수 (빈공간으로 냅두면 error)
- 3. String[] array = {"","",""};
   ====> 선언과 동시에 값을 넣을 경우 위와 같은 방식만 가능 (따로따로 X)

Index
- 배열의 요소마다 붙여진 일련번호 (배열의 방 번호)

HLL(High-Level Language)
- 10진수, 인간에 가까움

LLL(Low-Level Language)
- 2진수, 기계에 가까움

RunTime error (java)
- 실행 시 일어나는 에러 

Compile error (javac) 
- 프로그램 실행을 막는 error, 컴파일러가 이해하지 못하는 코드를 발견하면 오류 발생 (문법적 오류)

Operator (연산자)
- 함수를 실행시켜줌

Readability
- 가독성, 코드는 한 눈에 알아보기 쉽게 해야함

Validation Check
- 유효성 체크, 회원가입/카드 등록 등등

Flexible
- 유연한 코드를 작성해야 함 (ex. 배열 숫자 대신 length 사용)

Refactoring
- 결과의 변경 없이 코드의 구조를 재조정함

Initialization
- 초기화, Instance 변수는 Compile 시 자동으로 초기화해줌

Commend Line
- 커맨트창에서 작성한 글

Java는 모든 언어를 지원 (한글로 코딩 가능)

attribute = Field = 상태 = 속성 = 멤버변수

Method = behavior = 행위

class / Object / Instance
- class : 공통적이고 일반적인 특징을 추상화하여 뽑아낸 결과물
- Object : 현실 세계에 존재하는 모든 대상
- Instance : class에서 사용되는 객체 (A a = new A() => Instance를 생성)

RelationShips (관계)
- class들의 관계를 지정 (Generalization, Specialization)
- Field, Method는 공유(상속) 가능
- Constructor은 공유(상속) 불가능, 때문에 super();을 통해 호출 가능

Scanner
- 개념적인 객체를 추상화, 캡슐화하여 Scanner class를 만든다.
- Scanner를 사용하면 Runtime에 값을 입력

Coding Convention
- Java는 Variable namming Convention을 Camel을 사용 (C는 Snak)
- Class : public class Test {} => 첫번째 글자를 대문자로 사용
- Method / Variable : public void testName() / String testName => 소문자로 시작하고 중요한 단어 첫글자에 대문자 사용
- ex) System.out.println(); => class.variable.method();

Static Modeling + Dynamic Modeling = Object Modeling
- Static Modeling : attribute (명사)를 추출하는 것
- Dynamic Modeling : behavior (동사)를 추출하는 것

classPath
- Current dir => 현재 디렉토리(.) =======> 리눅스 명령어 dir에는 .이 생략되어 있음
- Parent dir => 상위 디렉토리(..)
- 기본적으로 지정되어 있지 않으면 .이 기본... => JAVA_HOME\jre\lib\rt.jar이 기본

Method Syntax => behavior Message
- return type이 존재함
- void의 경우 생략되어 안보일 뿐 존재

return문
- 메소드 실행 중간에 return이 있을 경우 return 다음 문부터는 실행 X

argument(인수) / parameter (매개변수)
- a.getString("A") => () 안에 있는 값이 인수가 됨
- public void getString(String a) => () 안에 있는 값이 매개변수가 됨
- 인수와 매개변수는 Data Type이 같아야함

Constructor (생성자)
- 객체는 서로 다른 상태값을 갖고 있어야함
- 기본적으로 생략 가능 (default constructor)
- 생성자 메소드 안에는 super()가 default고 기본 생략
- OverLoading을 사용하여 다양한 생성자를 만들고 객체(instance)의 초기값을 줄 수 있음
- class와 이름이 같고 반환 값이 없음 (타입 지정 안함) =====> ex. public A() {}

OverLoading / OverRiding
- OverLoading : 같은 메소드명을 가지고 있지만 매개변수(Parameter)의 데이터 타입과 개수가 다름 (같은 클래스 내)
- OverRiding : 상속 받은 부모의 메소드를 다시 재정의 (클래스 간)

super() / this()
- 생성자에서 사용
- super() : 기본 default 값, 상속받은 부모가 있다면 그 부모의 생성자를 실행 (매개변수 타입과 개수가 일치해야함)
- this() : 자신의 생성자를 호출 (매개변수 타입과 개수가 일치해야함) ===> 실행하는 메소드를 다시 호출하면 재귀 오류 발생

super / this
- Method, Field에서 실행
- super : 부모의 메소드 또는 필드를 실행
- this : 기본 default 값, 생략되어 있음

Package / import
- Package : java에서의 경로, .로 구분 ====> window는 폴더, \로 구분 / 유닉스 리눅스는 dir, /로 구분, class의 묶음
- OpenSoure의 경우 package는 유니크하게 만드는 것이 규칙, 대소문자 구분하지 않고 소문자를 원칙으로 함
- import : 다른 경로(package)에 있는 API를 사용할 수 있게 하는 구문, 컴파일러에게 소스파일에 사용된 클래스 패키지에 대한 정보를 제공

jar
- java의 압축 기술
- 용도 : App / Bean => Bean : 개발할 때 자주 쓰이는 라이브러리를 모델링하여 줌
- 누가 : 개발자

Instance Method
- Instance화 해서 쓸 수 있는 Method

/**
- java Document 주석
**/

Signature
- Method Signature : public void 메소드명() 
- class Signature : public class 클래스명

JVM + API = JRE
JRE + Tool API + javaLanguage = JDK (JavaPlatform)

Access Modifier (접근 제어자)
- public => 모두 가능
- protected => 상속 관계 접근 가능, 같은 package, class 가능
- (default) => 같은 package로 접근 가능, 같은 클래스 가능
- private => 같은 클래스 내에서만 가능

Modifier (제어자)
- static : java는 실행되면 쭉 내려오다 static 부터 메모리에 적재, 클래스명.메소드(변수)로 접근 가능
- final : 상태 값 변경 불가능, class는 상속 불가능
- absotract

Instance 변수
- 서로 다른 상태 값을 가짐

class 변수 (static int i)
- 공유함