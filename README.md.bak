# 용어 정리

## System ( 시스템 )

 +  정보를 처리하는데 사용되는 프로그램 등, 절차 데이터 및 기기들의 다양한 집합체

## Modeling ( 모델링 )

- 모형 제작 => 기획  
시스템 구축시 구현전 결정하는 모든 활동.(요구사항 정의, 분석 , 설계 )

## UML 

- `Unified Modeling Language`로 표준화된 범용 모델링 언어.

## CSV ( 콤마 세퍼레이터드 밸류 )
- `comma separated values`
- 구분선  


## Compile ( ByteCode ) 

- `.java` 파일을 `.class` 파일로 변환 시켜주는 것.

## Variable ( 베리어블 )
- 변수

## Platform ( 플랫폼 )
 - 특정 장치나 시스템에서 이를 구성하는 기초가 되는 틀 또는 골격을 지칭하는 용어.  
 ex) 운영체제의 플랫폼은 PC. 아래한글의 플랫폼은 운영체제임.

## Identifier (아이덴티파이어)
- 식별자 or 고유의 이름.
- numbering을 하지않는다.
  
## JRE ( Java SE Runtime Environment )
- 자바를 돌아가는 환경.
- `java API`와 `VM (버츄얼 머신)`을 합친 것

## JDK ( Java Development Kit )
- 개발하기 위해 사용하는 도구.

## JVM ( Java Virtual Machine )
- 어느 운영체제 상에서도 실행될 수 있게 하는 것
- 프로그램 메모리를 관리하고 최적화하는 것

## src
- `source`의 줄임말  

## Runtime error ( 런타임 에러 )
- `Compile`에는 문제가 없으나 , `run` 했을 때 에러 발생

## API ( 어플리케이션 프로그래밍 인터페이스 )
- `Application programming Interface`
- 응용 프로그램에서 사용할수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할수 있게 만든 인터페이스 

## literal ( 리터럴 )
- 그 자체로 값을 의미하는 것 =>  <u>`0`</u> 을 의미
    ```java
    int i = 0;
    ```
## path
- 사람은 자신이 만든 파일이 어디에 있는지 알 수 있으나 컴퓨터는 모르기 때문에 `경로`를 지정해 주는 것.

## class path 
- 설정하지않으면 `.` 으로 `default값`으로 지정  
- 해당하는 `class`가 해당 위치에 있는 `instance class`를 찾아간다.

## keyword
- 예약어  
  `boolean`, `class`, `for`, `if` 이런것을 의미

## casting 
- 형변환   
- ***08_11 수업정리***  
  
## operator ( 오퍼레이터 )
- 연산자??
- `.` , `new` 같은 것 ????
-  new 새로운 메모리 할당.

## debug
- 오류를 잡는 행위

## Readability ( 리더빌리티 ) 
- 들여쓰기
- 가독성

## return 
- 돌려받다 or 돌아가다.  
  돌려받을시엔 무조건 `value`만 돌려 받을 수 있다.

## refactoring ( 리팩토링 )
- 소스를 보안하는 행위.

## initialize (이니셜라이즈)
- 초기화

## field
- 멤버변수 or `전역변수`
- 상태,속성의 정보.

## class 변수, class 메소드
- static이 붙은 Variable, method는 `bean 실행`시 우선순위 1순위로 적재되고 class를 `Instance`를 하지않아도 `className으로 호출`이 가능.

## Instance 변수
- 인스턴스 변수 or 참조 변수 

## 지역변수
- `method` 안에 있는 변수

## beans
- `object modeling`한 class.
- real world 를 `class`로 표현한 것. 
- `main`이 없다. 

## Hard coding ( 하드코딩 )
- 조건에 값을 대입하는 것

## Camel Case(카멜 케이스)
- `Identity Fire`할 때 낙타등처럼 단어씩??마다 대문자를 섞는 것

## Sorting ( 소팅 )
- 정렬

## extends
- `Inheritance` 개념
- 확장, 공유, 상속
- 하나의 클래스엔 하나밖에 상속이 되지않는다.
  ```java
  public class ChildClass extends ParentClass {
	  ...
  }
  ```

## Information Hiding ( 인포메이션 하이딩 )  
- 정보은닉 - `캡슐화`와 관련성이 높다. 

## attribute ( 어트리뷰트 )
- 명사 - 데이터타입과 변수 선언을 말한다.
- Field (필드), State (상태)

## behavior ( 비헤이버 )
- 동사 - 기능,함수(function), 메서드(method)를 말한다.



## instance 생성 
- 하드디스크에 있는 class를 메모리에 할당 하는것.

## Method Syntax 
- 메서드 명령어
- **좀더 공부해야 함**

## message 
- 객체와 객체가 커뮤니케이션 하기 위해 생긴 것
- `인자`, `Paramiter (매개 변수)`

## 인자 
- `method` 의 `()안`의 보내는 쪽을 말한다. 
- - 호출할 때 쓰면 인수

## paramiter(매개변수) 
- method 의 ()안의 받는쪽 
- method 만들때 넣는 것이 매개변수

## Constructor ( 컨스트럭스 ) - 생성자
- bean을 생성시 `default` 값으로 있다.
- `instance 변수`의 인자를 받아 `Constructor`의 `Overloading`으로  인해 다양한 상태, 정보 등 멤버 변수를 초기화 시켜 다양한 참조형 데이터를 생성 할 수 있다.
- `return`을 명시하지 않는다.
- -`Initializr` 하는 method

## getter method, setter method
- 객체 지향의 특성 중 `정보 은닉(캡슐화)`을 가장 잘 보여주는 메서드.
- getter, setter를 통해 멤버 변수의 값을 변경, 호출을 할수 있다.
- 무조건 get,set을 써야하는 것은 아니지만 개발자들 사이에서 `암묵적인 룰` 같은 개념 이다.

## overloading 
- 하나의 공통 된 `Behavior (행동)` or `method`를 다른 인자값 또는 개수를 주어 다른 결과값을 출력 하는 것. 

## validation ( 벨리데이션 )
  -유효성 검사.


## super와 this
> Constructor와 연관
- ### this
  
  ---
	현재 클래스의 인스턴스를 의미한다.  
	즉, 현재 클래스의 `Field`나 `method`를 지정할 때 사용합니다.  
	this가 지정하는 `Field`나 `method`를  현재 클래스 안에 없으면 `상속` 되어있는 곳까지 찾아가서 찾아본다 => **확인 필요**
	```java
	public class Example{
		String str;
		
		public Example (){
			this.str = "예시";	
		}
	} // 결과 값 : str = 예시 
	```

- ### this() 

	---
	현재 클래스의 Constructor를 호출한다.  
	**자기 자신을 호출할 순 없다**, constructor이 recursive 때문에 재귀하기 때문에 에러가 발생한다.
	```java
	public class Example{
		String str;
		int i;
		public Example (String str){ // str = "예시"
			this.str = str;	
		}
		public Example (int i){ 
			this.i = i;	
		}
		public Example (String str, int i){//  str = "예시" i = 1
			this(str);
			this(i);
		}
	} // 결과 값 : str = 예시 , int = 1 ;
	```



- ### super

	---

	자식 클래스에서 사용이 가능하고, 상속 받은 부모 클래스의 Field를 참조할 때 쓴다.
	```java
	public class Parents{
		String str;
	}
	
	public class Example extends Parents{
		String str;
		public Example (){
			super.str = "예시";	
		}
	} //Example.str = null , Parents.str = 예시 
	```
- ### super()
	
	---

	부모 클래스의 Constructor를 명시적 호출한다.  
	아무것도 없을 때 super()값이 `default`  
	상속이 안되있을 경우 `error` 발생 
	```java
	public class Parents{
		String str;
		int i;
		public Parents (String str){
			this.str = str;	
		}
		public Parents (int i){
			this.i = i;	
		}
		public Parents (String str, int i){
			this(str);
			this(i);
		}
	}
	
	public class Example extends Parents{
		String str;
		int i;
		public Example (String str, int i){ //  str = "예시" i = 1
			super(str,i);
		}
	} 
	/*
		Example.str = null;
		Example.i = 0;

		Parents.str = 예시;
		Parents.i = 1;
	*/
	```

## overriding 
- 부모 클래스에 있는 method를 자식 클래스의 method로 동일하게 만드는 행위 
- 올라타다.
- method를 `upgrade`한다?

## commandLine argument 
- 명령행 매개변수 ( `CMD` )
  ```cmd
  java CalssName 여기 있는 것
  ```

## signature (시그니처)
- 선언 부분
  ```java 
  public final class String extends Object{
	//public final class String extends Object 까지가 시그니처
  }
  ```

## Polymerism ( 폴리머피즘 ) - 다형성
- 하나의 인터페이스에 다양하게 쓰이는 것.

## package
- java의 디렉토리.
  		
	```
	windows - 폴더(\) , Linux - 디렉토리(/), java - package(.)
	```

## Open Source ( 오픈소스 )
-공개적으로 액세스할 수 있게 설계되어 누구나 자유롭게 확인, 수정, 배포할 수 있는 코드.

## Access modifier ( 액세스 모더파이어 ) -접근 제어자
>맴버 또는 클래스에 사용되어 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역활.  `캡슐화의 중요성`

> private -> default -> protected -> public  



  - ### Private (프라이빗)
	
	---
	> `method` , `Field`

	`같은 클래스` 안에서만 접근이 가능하고 다른 클래스나 외부에서 접근을 제한한다.  



  - ### default (디폴트)
  
  	---
	>`class` , `Method` , `Field` 

  	`같은 클래스`, `같은 패키지`에서 접근이 가능하다.


  - ### protected (프러텍티드)

	---
	> `Method` , `Field`

  	`현재 클래스`,`같은 패키지`, `상속된 자손`까지 접근이 가능하다.



  - ### public (퍼블릭)
  	
	---
	>  `class` , `Method` , `Field`

	  `같은 클래스`, `같은 패키지`, `상속된 자손`, `전체`다 접근을 허용한다.
  
## recursive 
  - 재귀하다, 무한

## Modifirer ( 모디파이어 ) - 제어자 
> class, ,Field, Method의 선언부에 함께 사용되어 부가적인 의미를 부여한다.

  - ### static 
  
	---
	>`Fileld` , `Method`

	공통적인 의미를 가지고 있다.  
	**instance**를 선언하지 않아도 다른 클래스에서 **참조**,**호출** 할 수 있다.  
	클래스가 메모리에 로드될 때 우선순위.
	
	- static변수 - `클래스변수`
  
   		instance에 관계 없이 `같은 값`을 갖는다.  
		`클래스가 메모리에 로드될 때 생성`된다.  
		ex) 남자 고등학교의 학적 시스템 = **성별**


	- static메서드

   		instance를 생성하지 않아도 호출이 가능하다.  
   		static 메서드 내에서는 `인스턴스 멤버를 직접 사용할 수 없다`.

  - ### final 

	---
	>`class` , `Fileld` , `Method`
    
	**마지막의, 변경될 수 없는** 이라는 의미를 가지고 있다.

	- final class
 
   		> `변경될수 없는 클래스`이며 확장이 불가능한 클래스.  
		`상속이 불가능`하다.

	- final field 
		
		> 값을 변경할 수 없는 `상수`가 된다.
	
	- final Method 
  		
		> `Overriding`을 통해 `재정의 될 수 없다`.

  - ### abstract 
  	
	---
	>`class` , `Method`
	
	**미완성** 이라는 의미를 가지고 있고 method의 선언부만 작성하고 구현 하지않는 추상메서드를 선언하는데 사용한다.  
	Instance 생성 불가  
	**추상**, **형태만 잡아놓는 것** 


	- abstract class

		> 클래스 안에 `추상 메서드가 선언`되어 있음을 의미한다. 
	   
	- abstract Method

		> 선언부만 작성하고 구현은 작성하지 않는 `추상메서드`를 의미한다.
	   
	```java
	abstract class AbstractTest { 
		abstract void move(); 
		}

	```

## Instance Casting

  - ### 묵시적 형변환  

	---
	자손클래스에 있는 `추가된 기능`은 사용할 수 없다. 하지만 `overriding` 된것은 자신의 method를 재정의 했기 때문에 `사용이 가능`하다.
	
  - ### 명시적 형변환   

	---
	자손클래스의 추가된 기능을 다시 사용하게 하기 위해 명시적()으로 사용해 다시 사용할 수 있다.

	```java
	class Super{	
    ///method
		public void a (){
			System.out.println("SuperClass의 a()");
		}
	}
	class Sub extends Super{
		///Overriding
		public void a (){System.out.println("overriding 된 Sub = a()");}
		///Method
		public void b (){System.out.println("Sub = b()");}
	}
	public class CastingTest{
		//Main
		public static void main(String[] args) {
			Super superReference = new Sub(); //==> 묵시적 형변환.
			superReference.a(); //==> overriding되지 않은 method를 호출한다.
			//superReference.b(); // b()메소드를 찾을수 없다.
			Sub subReference = (Sub)superReference;//==> 명시적 형변환.
			subReference.a();
		}
	}
	```

## 분산 환경 

  - 네크워크를 통해 여러 os 가 모인 환경.

## 아스키 코드

## 인코딩

## 엔코딩

## 다이아몬드 프러블럼

## Interface
 > pure abstract class - 순수한 추상클래스
 - abstract를 생략
 - 상속, 공유가 불가.
 - 구현되지않는 것을 실체화 함.
 - 특별한 클래스
 - 추상된 기능을 빼놓는 것.
 - 기능을 통일을 위한 인터페이스 사용
 - modeling시 기능의 정의를 해서 재사용성을 높힘

 ### 왜??
  > 해당 하는 기능을 다른 곳에 쓰기 위해 ( 재사용성 )
  TV - 볼륨
  라디오 - 볼륨
  스피커 - 볼륨
일반화 되지않는 것에 상속을 해 abstract 하는것보다 인터페이스를 이용해 볼륨 이라는 기능만 정의해 놓으면 어디서든 쓸수 있다.

## ~is a~ 관계
 > **Generalization**, **Specialization**, **Realization**는  
 ~ 는 ~ 이다 (~is a~) 관계 형성
 - exteds, implements 라는 keyword 존재.

## ~has a~ 관계
 > **Association**는 ~는 ~를 가지고 있다 (~has a~)관계

 ### dependency
 > 버리는 관계
 ```java
 public void charge() {
      B b = new B(); // 버리는 관계;
      System.out.println(" :: 500원 \n");
 }
 ```
 ###
 > 가지고 있는 관계
 ```java
 field 에 B b = new B();// 갖고 다니는 관계.
 public void charge() {
	this.b~ // 
        System.out.println(" :: 500원 \n");
 }
 ```

 