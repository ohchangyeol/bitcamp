용어 정리 해야할 것들
	아스키코드
	인코딩
	엔코딩
	다이아몬드 프러블럼

수업 복습
this ,super에 대한 복습
instance 묵시적 형변환
static , abstract 간단 정리

버스차지를 이용해 다형성 복습

===============수업
## abstract class - 추상 클래스

> 인스턴스 생성불가

## interface 
> pure abstract class - 순수한 추상클래스

 - abstract를 생략
 - 상속, 공유가 불가.
 - 리얼리제이션을 구현
 - 구현되지않는 것을 실체화 함.
 - 특별한 클래스
 - 추상된 기능을 빼놓는 것.
 - 기능을 통일을 위한 인터페이스 사용
 - modeling시 기능의 정의를 해서 재사용성을 높힘
 - 다중 상속 가능.
 
왜? 그 기능을 다른곳에서 쓰기 위해.

tv - 볼륨
라디오 - 볼륨
ㅁㅁㅁ - 볼륨

 일반화 되지않는 것에 상속을 해 abstract 하는것보다 인터페이스를 이용해 볼륨 이라는 기능만 정의해 놓으면 어디서든 쓸수 있다.

Specialization Generalization Realization  = is a~는 ~이다. 키워드가 있음. extends , implements

dependency Association = 테크닉

dependency

public void charge() {
	B b = new B(); // 버리는 관계;
        System.out.println(" :: 500원 \n");
    }

Association

field 에 B b = new B();// 갖고 다니는 관계.
public void charge() {
	this.b~ // 
        System.out.println(" :: 500원 \n");
}


인터페이스에 모든메서드는 abstract 가 붙는다.
	field 는 final static 이 붙는다.

인터페이스는 완전한 추상 메서드
abstract는 어떤것은 추상 어떤것은 일반 메서드.


```java
	System.out.println(Deposit.deposit);    //==>static의 접근방식은 ?
        System.out.println(hb.payOut);          //==>static의 접근방식은 ?

        //field 의 상태값을 변경해보자.
        // Deposit.deposit="입금";
        // PayOut.payOut="출금";
        //==> compile Error 발생 interface에 선언되는 변수는 final static의 특징을 갖음
```

용어 정리 할것

field = 인스턴스 변수
	멤버변수
localVariable - 지역변수 클래스영역 이외의 영역
		메서드. 생성자, 초기화 블럭 내부
		초기화가 되지않으면 사용할때 에러가 발생한다.

Garbage = 메모리에 떠있고 사용할수 없는 istance 를 말한다
 garbage collector : Java에서는 개발자가 프로그램 코드로 메모리를 명시적으로 해제하지 않기 때문에 더 이상 필요 없는 객체를 찾아 지우는 작업을 하는 애
 garbage collecting 
 garbage collection JVM의 가비지 컬렉터가 불필요한 메모리를 알아서 정리

Object class 는 java 의 최상위 class다 (api의 최상위 클래스)


reference 를 찍으면 내부적으로 toString()을 찍는다.

toString 을 찍으면 왜 쓰레기 값이 나오는지? api 참고 

String class가 toString()메서드를 오버라이딩 함 .

```java
	String name = "오창열";
	String str = name;
	System.out.println(str);
	System.out.println(str.toString());
```
toString()는 생략이 되있음.

레퍼런스형 타입의 상태값을 비교하고싶을땐 equals
```java
B b1 = new B(1,"홍길동");
B b2 = new B(1,"홍길동");
System.out.println("b1.equals(b2) : "+b1.equals(b2));//==> false
```

 - 오브젝트가 참조하는 주소값이 다르기 때문에 b1 == b2와 같은 원리다.이것을 해결하기 위해 오버라이딩이 있고 오버라이딩을 하게 되면....

 - 
    public boolean equals(Object obj) {
        return (this == obj);
    }

b2는 Object로 묵시적 형변환이 되기 때문에 b 에 있는 no를 가져올수 없게 되는것
그것을 가져오기 위해 명시적 형변환을해줘야 함.