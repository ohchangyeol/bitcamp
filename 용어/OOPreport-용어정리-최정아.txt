

<<< 용어정리 >>>

▶System
 필요한 기능을 구현하기 위해 관련 요소를 어떠한 법칙에 따라 조합한 집합체
 오프라인의 작업을 온라인 상에서 더 쉽고 편리하게 사용할 수 있게 함.

▶모델
 작품을 만들기 전에 미리 만든 물건.

▶modeling
 기획하는 것.
 시스템 구축시 구현전 설정하는 모든 활동.
 -구축할 시스템 정의
 -요구사항 정의
 -구체적인 계획(분석, 설계)
 -결과물 : 모델
 -표기법 : UML

▶UML(Unified Modeling Language)
 시스템 개발 과정에서 개발자간의 의사소통을 원활하게 하기 위한 표준화된 모델링 언어.
개발자와 개발 프로젝트를 위한 시각적 도구로 개발 프로젝트를 위한 설계도라고 볼 수 있음.
서비스에 들어가는 정보와 복잡한 구조를 단순하게 보여줄 때 주로 사용됨.
 통합적(표준화된 기법을 제공함), 시각적(풍부한 시각적인 표현 모델을 제공함), 독립적(시스템의 종류나 규모에 관계없이 적용이 가능함)
UML 구성요소 : 사물, 관계, 다이어그램

 -실무에서 자주 사용되는 UML은 크게 세 가지 타입이 있음.
1. Use case UML-실제 시나리오를 보여줌. 실제 세상에서 벌어지는 일을 사람과 역할 위주로 그려낸 UML
 가장 손쉽게 이해할 수 있는 케이스로 현실의 사용자가 누구와 어떤 행동을 하는지 그 과정에서 누가 어떤 결과를
가져오는지 사람, 역할을 중심으로 전체 서비스를 보여줌. 서비스의 큰 틀을 이해할 때 도움이 되나 각각의 행동이나
과정에서 어떤 정보가 오고 가는지 그 정보가 어떤 것인지는 자세하 알 수 없음.
2. Class UML-정보들의 관계를 보여줌. 서비스에 들어가는 중요한 정보를 박스로 만들어 연결시킨 UML
 서비스의 중요 정보들을 박스로 연결해서 보여줌. 그리고 이 박스들이 무엇을 중심으로 묶여 있는지 각각의 박스 안에 
중요한 정보는 무엇을 담고 있는지를 보여줌. 서비스에 들어가는 핵심 정보를 한눈에 보여주지만 어디까지나 중요한 정보만을
압축해서 보여준 것이기 때문에 모든 정보를 담고있찌 않아 실제 개발을 위해서는 더 많은 정보가 필요함.
3. Sequence UML-데이터의 순서를 보여줌. 데이터의 흐름을 순서대로 표현해 어떤 결과가 나오는지 보여주는 UML
 사다리 게임을 하듯 왼쪽부터 오른쪽 아래로 내려가는 그림임. 데이터가 어떻게 흘러가고 최종적으로 어디에서 어떤 결과가 나오는지를
알려주게 됨. 시퀀스 UML은 말 그대로 순서대로 흘러가는 그림이기 때문에 개발자에 대한 높은 이해도가 있지 않아도 데이터의 흐름을
읽어낼 수 있음. 하지만 제한된 부분만을 보여주기 때문에 서비스 전체를 그려낼 순 없음.

▶coder
 분석, 설계 능력은 없으나 UML을 알고 모델을 이해하여 특정 언어로 구현할 수 있음.

▶Typist
 코더가 만든 코드를 가지고  copy and paste함.

▶Data
 이론을 세우는 데 기초가 되는 사실 또는 바탕이되는 자료

▶Data Base
 데이터를 효율적으로 처리하기 위하여 개발된 것으로 같은 데이터가 중복되는 문제를 없앨 수 있으며 업무가 확대되어도
새로운 파일을 준비할 필요가 없다는 장점이 있음.

▶JRE(Java Runtime Environment)-JDK의 일부.
 자바 언어로 개발된 소프트웨어를 실행하기 위해 필요한 플랫폼. 플랫폼으로 부터 독립적임.

▶JVM(Java Virtual Machine)
 자바 바이트 코드와 컴퓨터 운영 시스템 간의 번역기 역할을 함.
JVM을 이용하여 사용자는 매킨토시, 윈도95, 유닉스 등 어떤 많은 다른 컴퓨터 플랫폼에서도
자바를 실행시킬 수 있다. 그러나 JVM은 자바 명령을 한번에 읽고 실행시키기 때문에 컴파일러보다 느리다.
 
▶JDK(Java Development Kit) / SDK(Software Development Kit)
 자바 개발 도구. JVM(Java Virtual Machine)과 컴파일러, 디버거, 자바 애플릿 및 응용 프로그램 개발을 위한 도구들이 포함됨.
 -J2SE(java standard edition) : core java라고도 하며 가장 기본적이고 표준적인 java버전. 다른 모든 에디션의 기초가 되는
가장 순수한 자바 형식이며 다양한 범용 API(java.lang, java.util등) 및 많은 특수용도 API로 구성됨. 주로 데스크톱 환경용 
응용 프로그램을 만드는데 사용. 
 -J2EE(java enterprise editoin) : 커뮤니티 중심의 에디션. 가장 널리 사용되는 웹개발 표준중 하나이며
HTML, CSS, JavaScript등을 사용하여 웹페이지와 웹서비스를 생성함.
 -J2ME(Java mobile edition) : 모바일을 위한 버전이나 현재는 거의 사용되지 않음.

▶자바 플랫폼
 자바 실행환경과 개발환경을 제공하는 것.
 자바 프로그램을 실행하기 위해서는 JVM과 개발에 필요한 표준 환경만 맞추면 자바 프로그램은 모든 환경에서 동일하게
동작한다. 

J2SE 플랫폼
자바 어플리케이션

▶OOP(Object Oriented Programming)
 객체를 정의하고 객체간 협력을 프로그래밍 하는 것임. 예를들어 학생이 밥을먹고 버스를 타고 학교에 가는것을 
객체인 학생, 밥, 버스, 학교 사이에 일어나는 일을 프로그램으로 구현하는 것임. 밥을 먹는다는 행동은 학생이라는 객체와 밥이라는
객체가 있어 학생이 밥을 먹는 협력으로 이루어지며 학생이라는 객체가 학교라는 객체에 가는 행동이 발생하는 것으로 먼저
객체를 만들고 객체 사이에 일어나는 일을 구현하는 것임.  객체지향 프로그래밍을 할때는 객체를 먼저 정의하고 각 객체간 협력을
어떻게 구현할 것인지를 고민해야 함. 
장점으로는 데이트나 기능에 변화가 생기더라도 관련된 객체만 변경하면 되기 때문에 관리가 용이하고 조금 더 의미있는 단위로
나누기 때문에 코드를 이해하거나 다른 프로그램에서 재사용하기에 수월하며 꼭 전체가 완성되지 않더라도 일부 기능만 사용해 볼 수 이씩 때문에
테스트에도 유리하다는 점이며 단점은 코드를 잘 나누고 설계해야 하기 때문에 설계단계부터 많은 노력이 필요하며 작은 규모의 프로그램이나 
데이터가 거의 바뀌지 않는 경우에는 설계과정없이 만드는게 더 빠르고 효율적일 수 있어 적합하지 않으며 저장공간을 많이 차지하고 상대적으로
실행속도가 느리다.

▶OOPL(Object Oriented Programming Language)

▶compile
 사람이 사용하는 언어를 컴퓨터가 이해할 수 있는 언어로 변경하는것.

▶bytecode(바이트코드)
 자바 프로그램의 컴파일된 형태. 자바 프로그램이 바이트코드로 변환되면 네트워크를 통해 전송될 수 있고
JVM에 의해 실행될 수도 있다. 그러나 자바 컴파일러는 각 플랫폼에 독립적인 바이트코드를 표현하는데
제약을 받기 때문에 효율적인 코드를 생성하는데 한계가 있어 바이트코드가 네트워크와 같은 실행
환경에서 효과적으로 실행하려면 효율적인 코드에 대한 변환이 요구되며 확장자는 .class 이다.

▶자바 애플릿(Java Applet)
 자바 컴파일러(javac.exe)로 컴파일되고 웹 브라우저 상에서 작동되는 프로그램.
웹 브라우저는 HTML파일만 인식할 수 있기 때문에 자바 애플릿을 실행하기 위해서는 APPLET 태그가 정의된 HTML파일을 만들어
웹 브라우저에서 불러야 함.

실행과정
자바 애플릿 소스(sample.java)->자바 컴파일러(java.exe)->자바 바이트코드(sample.class)->애플릿 뷰어(appletviewer.exe) 또는
웹 브라우저(크롬 등)->실행결과.

▶OS(Operating System)
 모든 하드웨어와 모든 소프트웨어를 관리하는 컴퓨터시스템의 한 부분인 실행 관리자. 누가 시스템을 사용할 수 있고 어떻게 사용할 수 있는지를
관리함.

▶Platform(플랫폼)
 특정 장치나 시스템에서 이를 구성하는 기초가 되는 틀 또는 골격을 지칭하는 용어.
 상대적임. ex) 운영체제의 플랫폼은 PC. 아래한글의 플랫폼은 운영체제임.

▶Open Source(오픈소스)
 오픈소스 소프트웨어(OSS)라고도 한다. 소프트웨어의 설계도에 해당하는 소스코드를 인터넷등을 통하여 무상으로
공개하여 누구나 그 소프트웨어를 개량하고 재배포할 수 있ㄷ록 하는 것 또는 그런 소프트웨어를 말함.

▶ANSI

▶App(Application)(앱)
 운영체제(OS)에서 실행되는 모든 소프트웨어. 

▶software
 컴퓨터 프로그램과 그와 관련된 문서들을 총칭하는 용어.

▶.exe(Executable)
 일반적인 파일 확장자로 컴퓨터 프로그램의 실행파일을 가리킴.

▶확장자
 파일의 형식이나 종류를 구분하기 위해 파일명 뒤에 붙이는 알파벳 문자열. 파일의 종류가 많아지다보니 파일 속성을
구분해야 할 필요성에 의해 파일 확장자를 사용하기 시작함.
파일의 용도를 이해할 수 있음.

▶DOS(Disk Operating System) 창 = Console(컴퓨터를 제어하기 위한 계기반)
 디스크(프로그램이나 데이터가 컴퓨터의 메모리 내에서 더이상 사용되지 않을 때 이것을 보관하기 위해 사용하는 일종의 컴퓨터 창고)
입출력을 포함한  OS, 시스템 소프트웨어를 말함.

▶i18n
 국제화. 출판물이나 하드웨어 또는 소프트웨어 등의 제품을 언어 및 문화권 등이 다른 여러 환경에 대해 사용할 수 있도록 지원하는 것.
 지역화(l10n)

▶path
 사람은 자신이 만든 파일이 어디에 있는지 알 수 있으나 컴퓨터는 모르기 때문에 경로를 지정해 주는 것.

▶CSV(comma separated value)
 쉼표를 기준으로 항목을 구분하여 저장한 데이터.

▶SQL(Structured Query Language)-구조화 질의어
 데이터베이스를 구축하고 활용하기 위해 사용하는 언어.
관계형 데이터 모델로 표현되는 데이터베이스를 다루는 언어로 가장 널리 사용되고 있다.
SQL은 영어 문장과 유사하므로 초보자들도 비교적 쉽게 사용할 수 있으며
크게 데이터 정의언어(DDL: Definition Language)와 데이터 조작 언어(DML:Data Manipulation Language)로 나뉨.
 
▶Spread Sheet(스프레드 시트)
 수치계산, 통계, 도표와 같은 작업을 효율적으로 할 수 있는 응용프로그램. 예)엑셀

▶syntax(신텍스)
 (컴퓨터 언어의) 문법

▶API(Application programming interface)
운영체제와 응용프로그램 사이의 통신에 사용되는 언어나 메시지 형식.
프로그램 내에서 실행을 위해 특정 서브루틴에 연결을 제공하는 함수를 호출하는 것으로 구현됨.
그러므로 하나의  API는 함수의 호출에의해 요청되는 작업을 수행하기 위해 이미 존재하거나
또는 연결되어야 하는 몇 개의 프로그램 모듈이나 루틴을 가짐.
좋은 API는 모든 building block을 제공함으로써 프로그램 개발을 쉽게 해준다. 프로그래머는 그
block을 함께 합치기만 하면됨. API가 프로그래머를 위해서 만들어지긴 했지만 사용자 입장에서도
같은 API를 사용한 프로그램은 비슷한 인터페이스를 가지기 때문에 새로운 프로그램의 사용법을 배우기가 쉬워짐.

▶interface(인터페이스)
 서로다른 두 시스템, 장치, 소프트웨어 따위를 서로 이어주는 부분 또는 그런 접속장치.
사용자인 인간과 컴퓨터를 연결하여주는 장치로 키보드나 디스플레이 따위를 이른다.

▶Servlet(서블릿)
 서버에서 웹페이지 등을 동적으로 생성하거나 데이터 처리를 수행하기 위해 자바로 작성된 프로그램.

▶식별자(Identifier)
 프로그래머가 직접 만들어줘야 하는 이름. 예) 변수명, 클래스명, 메소드명

▶예약어(Keyword)
 프로그래밍 언어에 미리 정의된 의미있는 단어.
예약어는 식별자로 사용할 수 없음.

▶리소스(Resource)
 컴퓨터 시스템에 관한 여러가지의 자원을 총칭하는 말.

▶소팅(sorting)
 데이터를 특정한 조건에 따라 일정한 순서가 되도록 다시 배열하는 일.

▶리터럴(literal)
 그 자체로 값을 의미하는 것. 

컴파일 에러
런타임 에러

전취
후취

▶HLL(high level language)
인간에게 친숙한가. 자바는 HLL.

▶LLL(low level language)
기계에게 친숙한가

▶Lable(레이블)-identifier를 이용하여 반복문을 빠져나오는 것.
break 레이블명;
continue 레이블명;
레이블명 없이 break와 continue를 사용하면 현재의 가장 근접하고 있는 루프를 빠져나가지만 레이블을 이용하면
위치에 관계없이 레이블이 위치한 반복문을 빠져나간다.

▶value를 관리(call by value)-primitive data type
저장된 값을 넘겨줌.
 함수 호출시 전달되는 변수의 값을 복사하여 함수의 인자로 전달.
 복사된 인자는 함수 안에서 지역적으로 사용하는 변수.

▶참조값을 관리(call by reference)-reference data type
주소값을 넘겨줌.
 함수가 호출될 때 메모리 공간 안에서는 함수를 위한별도의 임시 공간이 생성.(함수 종료시 사라짐)
 함수 호출시 인자로 전달되는 변수의 레퍼런스를 전달.

▶리팩토링(Refactoring)
코드의 유지,보수를 용이하게 하기 위하여 수정, 보완 하는 것.

자바는 베리어블 네이밍 컨벤션이 camel case을 쓴다.
대소문자를 구별하지 않는 언어는 snake case.

1. OOP(Object Oriented Programming)
 현실 세계에 존재하는 모든 것들과 일련의 활동들을 컴퓨터로 옮기려면 그 일련의 과정들을 명확히 분석하여 설계하여야 하는데 그러한 활동을 하는 방법론 중 가장 인기있는 방법론으로 현실에서 현실에서 편지를 보내려면 편지지를 구매하고 수기로 내용을 작성하여 수령인 주소를 입력하고 우체국으로 가 편지를 부치는 일련의 과정을 컴퓨터에서는 메일을 이용하여 타이핑으로 내용을 작성하고 수령인 메일주소를 입력하고 보내기 버튼을 통해 원하는 내용을 전달할 수 있게 만드는 일련의 과정을 가능하게 하는것이 OOP임.

2. Object(객체)
 현실 세계에 존재하는 모든것으로 물리적인 사람, 선풍기, 책상등과 같은것은 물론 실체가 없는 주문, 생산과정등도 모두 객체.

3. Class 
 객체들의 행위와 속성을 추출하여 컴퓨터로 표현한 객체들의 모임으로 학생이라는 객체를 예를들면 이름, 학년등을 속성이라고 볼 수 있으며 학교에 간다, 버스를 탄다 등이 행위.

 시스템을 만드는데 필요한 객체들간의 공통적이고 일반적인 특성을 추출하는 추상화 작업을 통하여 병원이라는 시스템을 만들예정이면 사람이라는 객체의 이름, 나이, 몸무게등을 추출하여 클래스로 만든다.

4. abstraction(추상화)
 객체들간의 공통적이고 일반적인 특성을 추출하는 것으로 김철수와 김영희라는 학생들이 같은 학교에 다니고 있다면 A학교 학생이라는 것으로 추출하는 작업을 추상화 작업으로 이해했었음. 객체들간의 공통적이고 일반적인 특성을 추출하는것은 맞으나 만들려는 시스템에 따라 필요한 속성을 다르게 추출해야 하기 때문에 시스템에 의존적이다.

 만들려고 하는 시스템에 따라 필요한 속성이 달라짐. (depend on system)
 -병원 시스템을 만들때 이름, 키, 몸무게, 혈액형등 필요하지만 학원 시스템을 만들때는 이름, 전공등이 필요함.

5. Generalization(일반화) / Inheritance(상속)
 일반화는 상기 김철수와 김영희 학생이 A학교 학생이라는 점을 더 일반화시킨다면 수도권에 있는 학교를 다니는 학생으로 추상화 하는것. 
상속은 기존의 클래스를 재사용하여 한 클래스가 다른 클래스의 필드와 메소드를 물려받아 기존 클래스를 그대로 사용하거나 새로운 메소드를 추가하여 사용가능하게 하는 것.
==>자손클래스(child=sub), 조상클래스(parent=super)

6. Specialization(구체적)
 Specialization 객체들이 가진 특성을 좀 더 세분화 하는 것으로 김철수와 김영희 학생은 A학교 학생이다에서 1학년이다 내지 1학년 1반 학생이다와 같은 방법으로 추출하는것.

7. Realization

 
8. Association(연관관계) ==>has~a
 한 클래스가 다른 클래스를 사용하는 경우 오랜 시간동안 같이할 객체와의 관계로 예를들면 자동차와 소유주의 관계...(?)

9. dependency
 한 클래스가 다른 클래스를 사용하는 경우에서 짧은 시간동안 이용하는 것으로 예를들어 자동차와 주유기의 관계...(?)

10, Polymorphism(다형성)
 한 타입의 참조변수로 여러 타입의 객채를 참조할 수 있도록 하는 것. 
 하나의 인터페이스를 다양하게 활용. 우리의 삶이 다형성.묵시적 형변환에 유용하게 쓰임.
 마우스가 어디 마우스인지 알 필요 없었음. 마우스 사용법만 알면 됨.
 운전하는 법을 배우면 차가 어떤 차량이든 운전이가능함.
 집에 TV가 변경됨. 어떤 티비인지 상관없음. TV 사용법만 알면됨.
 아래한글, 훈민정음, ms.word 는 다형성을 구현하지 않아서 불편함.
 
11. Encapuslation(캡슐화) / 절차은익 / 정보은익
 중요한 정보가 담겨져있는 클래스를 쉽게 바꾸지 못하도록 필요한 때에만 접근할 수 있도록 하는것으로 특정한 때에만 접근할 수 있게하여 원하지 않는 데이터가 되는것을 막고 외부로 노출시킬 필요가 없는 정보들을 숨기기 위해 사용하는 것.
 우리는 집 밖으로 나오면 information hiding된 캡슐화된 객체이지만 오픈해야하는 경우가 있음.
 식별성만 가지고 객체의 모든 정보를 알 수 없듯이 정보를 얻기 위해서는 물어봐야함==>getter method
 식별성만 가지고 객체의 이름, 직업, 평균수입등의 정보를 알 수 있다면 캡슐화되지 않았기 때문에 객체지향 코딩이라고 볼 수 없음.
 public <-> private
캡슐화된 정보는 그 사람이 말을 해줘야 알 수 있음.

12. RealationShip(관계)
 효율적으로 모델링하기 위해 공유하자.(속성과 행위의 공유)
 독수리, 코끼리, 고래의 이름과 이동방법이라는 공통적이고 일반적인 특성을 추출하여 동물 클래스를 만들고 해당 클래스를 공유하고 독수리, 코끼리, 고래가 각각 가지는 특징을 클래스로 만들고 동물 클래스를 공유하면 공통적인 동물 클래스의 이름,이동방법을 변경하면 공유하고있는 독수리, 코끼리, 고래의 클래스도 같이 변경되는 일관성을 가진다.

 추상화 수준에 따라 사물->식물, 식물->꽃, 꽃->국화 와 같이 확장할 수 있으며 국화는 꽃이다, 꽃은 식물이다, 식물은 사물이다(~is a~)로........

 ▶primitive data type은 묵시적 형변환시 물리적으로 크기가 큰 쪽으로 형변환됨.
 ▶reference data type은 묵시적 형변환시 개념적으로 크기가 큰 쪽으로 형변환됨.

 동물 a = new 동물(o)
 동물 a = new 사람(o) ==> 사람은 동물이다(o)
 사람 b = new 사람(o)
 사람 b = new 동물(x) ==> 동물은 사람이다(x)
  -> 하위는 상위를 대신할 수 있으나 상위는 하위를 대신할 수 없다.

 ▶ Hierarchy(계층화)
  일관성, 확장성, 재사용성으로 유지관리를 용이하게 함.
 
 ▶instance
 객체중에 내가 필요로한 일부만 뽑은것 ==>클래스.
 클래스를 메모리(물리적인 하디드스크)에 적재해서 사용할 수 있게 하는 것 ==> 인스턴스.


▶DeveloperTest는 developer가 어디있는줄 알고 실행하는지??
classpath를 따로 잡아두지 않으면 .(현재폴더)가 defalt임.

▶Naming Convention

▶camel case
대소문자 구분.
네이밍의 첫 단어의 첫 문자만 소문자로 표기하고 다음 단어에서 대문자로 표기하는 lowerCamelCase와 네이밍의 모든 단어의 첫 문자를 대문자로 표기하는 UpperCamelCase가 있다.

method-소문자로 시작해서 의미있는 단어에서 대문자.
class-대문자로 시작해서 의미있는 단어에서 대문자.

▶snake case 
대소문자 구분안함. 각 단어 사이마다 _를 사용하여 단어를 연결함.

. (current directory) - 현재폴더
.. (parent directory) -상위폴더

▶object modeing
객체들을 만들려고 하는 시스템에서 필요한 속성과 기능을 추출하여 표현하는것.

▶attribute==>Field에서 표현.
-명사를 추출 ==> static modeling

▶behavior ==> method에서 표현.
 -동사를 추출 ==> dynamic modeling

▶overloading 은 polymorphism 때문에 필요함.
 메서드 이름은 같으나 인자값을 다르게 줘서 메서드 호출시 다양한 행위를 시킬 수 있음.

 

 ▶객체지향이란 현실을 컴퓨터로 옮기는 방법론으로 객체들간의 공통적이고 일반적인 특성을 시스템의존적으로 추상화작업을 통해 클래스로 만든다. 클래스를 사용하기 위해서는 instance화 해야하며 클래스가 여러개 만들어지며 각 클래스들은 관계를 가진다. 

▶modulality(모듈러리티)
컴퓨터 시스템에 있어서 하드웨어 및 소프트웨어의 각 구성 요소의 일부를 변경하거나 증설할 때 그 변경이 전체에 영향을 미치지 않도록 어떤 부분만을 바꿀 수 있도록 설계된 것.

▶인스턴스 만드는 키워드?? new

▶변수의 초기화
멤버변수(클래스 변수와 인스턴스 변수)와 배열의 초기화는 선택이지만 지역변수의 초기화는 필수임.

▶매개변수(parameter)
메서드가 작업을 수행하는데 필요한 값들(입력)을 제공받기 위한 것.
일반적인 변수선언과 달리 두 변수의 타입이 같아도 변수의 타입을 생략할 수 없다.
매개변수의 개수의 갯수는 거의 제한이 없지만 입력해야 할 값을 갯수가 많다면 배열이나 참조변수 사용.
입력받은 값이 없는 경우는 괄호()안에 아무것도 입력하지 않는다.

▶인수(argument)
함수를 실행할때 매개변수로 넘겨주는 값.

▶오버로딩(overloading)
 -매서드의 이름이 같아야 한다.
 -매개변수의 개수 또는 타입이 달라야 한다.
 -반환 타입은 관계없다.

▶초기화(initialization)

▶
객체는 태어날때부터 상태가 다르다.
나중에 상태값을 바꾸는건 어색..
인간은 태어날때부터 상태가 다르니 거기서부터 시작하자..

▶생성자(constructor)
생성자의 이름은 클래스의 이름과 같아야 한다.
생성자는 리턴값(리턴타입)이 없다.
생성하는 특별한 행위를 하는 메서드. 생성도 행위임.
생성자는 상태값을 세팅.
클래스를 만들때 아무것도 입력하지 않아도 클래스이름();의 생성자가 생김-default 생성자.
매개변수가 있는 생성자를 만들어주면 디폴트 생성자는 생성되지 않는다.

▶feild를 인스턴스화 해야 쓸 수 있기 때문에 인스턴스변수라고도 할 수 있다.

▶setter method까지 있어야 완벽한 information hiding

▶recursive(재귀)

▶overriding
상위의 메소드를 하위에 똑같이 정의할 수 있다.

▶validation
유효성 체크

▶메서드 시그니쳐(method signature)
메서드를 구분시켜주는 요소로 메소드의 선언부에 명시되는 매개변수의 리스트를 가리킴.
두 메서드가 매개변수의 개수와 타입, 순서까지 같다면 두 메서드의 시그니쳐는 같다고 할 수 있음.
==> 메서드 오버로딩은 서로 다른 시그니처를 갖는 여러 메서드를 같은 이름으로 정의하는 것.

클래스 시그니쳐


컨스트럭터를 오버로딩하는 이유? 객체는 다양한 상태를 갖기 때문.

▶명령행 매개변수(CommandLine argument)
 1) 프로그램 수행을 시작할때 명령행에 입력하여 전달, 입력 시기 1회
 2) Java Application에서만 활용 가능(Servlet, Applet에서는 사용 불가)
 3) 입력 방법
  - 표준입력 : 표준 입력(키보드)을 통해 정보 입력(반복입력) 가능, 텍스트 모드에서 수행되는 Java Application에서만 활용가능
  - 파일로부터의 입력 : 파일 입출력 API를 활용하여 파일을 열고 입력

폴리모피즘을 지원하는 수단?
1개의 클래스에선 오버로딩. 2개 이상의 클래스에서는 오버라이딩.

객체는 식별성에 의해 움직임.
다른 객체를 부를수도 있지만 내가 나를 부를 수 있음. this.으로 this.은 생략가능

folder==directory==package(csv==> \ / . )

src ==source

instance method
인스턴스 메소드는 인스턴스에 속한 것이기 때문에 반드시 인스턴스를 생성해야 사용할 수 있으나
클래스 메소드는 클래스에 속한 것으로 인스턴스를 생성하지 않고도 실행 가능함.(static)
 -->클래스이름.~ 으로 접근

main method
JVM이 제일먼저 call.
가장 먼저 읽어들여 명령들을 수행하고 그것이 끝나면 프로그램을 종료하기 때문에 결과값이 없어 항상 void.

instance valiable(인스턴스 변수)

/**  ==> 자바 document 주석

jre와 자바 tool 합친거 자바 플랫폼 또는 JDK

자바 VM과 API 합친게 JRE

컴파일시 -d 옵션의 사용
인수에서 -d . $(FileName)로 변경

▶static field 상태같지 않은 상태이니 공유해서 써라.
▶static method 상태와 무관한 메서드. 단순기능.
▶Integer.parseInt()=단순하게 리턴하고 상태를 변경하는건 없음. 그래서 스태틱

▶final field 마지막 상태값.(변경되면 안되는 상태값).
▶final method 마지막 메서드. 오버라이딩 하지 말아라. 
▶final class 객체지향의 특징은 하이라키. 확장하지마라. 마지막 클래스.(하이라키 포기)

getter/setter -> 캡슐화/ infomation hiding을 가장 잘 보여주는 메소드.

▶상수는 자바진영에서 대문자로 쓴다.
예)Math.PI








 
